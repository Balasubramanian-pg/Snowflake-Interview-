# What Are Architecture Layers and Why Do They Matter?

> [!Information]
> Architecture layers organize a system into distinct, hierarchical components, each with a specific responsibility, to manage complexity and improve maintainability.

## Why This Matters
-   **Decision Support**: Guides critical decisions on how to structure code, where to place business logic, how to organize development teams, and which technologies are appropriate for different system parts by providing a clear framework for responsibility assignment.
-   **Breaks or Costs Time**: Without clear layering, systems become monolithic and tightly coupled ("spaghetti code"), leading to difficult maintenance, slow feature development, increased bug introduction, and poor scalability. Misplaced logic can result in security vulnerabilities, performance bottlenecks, or inconsistent behavior across the application.
-   **When You Would Look This Up**: Essential when initiating a new software project, planning a major refactoring, onboarding new engineers to a complex system, diagnosing issues related to system complexity and coupling, or evaluating system performance and scalability bottlenecks.

## Key Points
-   **Separation of Concerns**: Each layer focuses on a distinct set of responsibilities (e.g., user interaction, business rules, data storage), leading to cohesive units and preventing unrelated concerns from intermingling.
-   **Hierarchical Structure**: Layers are arranged in a strict hierarchy, where higher layers depend on and consume services from lower layers, establishing a clear flow of control and information.
-   **Controlled Dependencies**: Dependencies are strictly unidirectional (e.g., Presentation → Application → Domain → Infrastructure), preventing circular references and simplifying the system's mental model and evolution.
-   **Abstraction and Encapsulation**: Lower layers expose well-defined, stable interfaces to higher layers, abstracting away internal implementation details. This encapsulation allows changes within a layer without rippling effects across the system.
-   **Modularity and Testability**: The isolation of concerns enables layers to be developed, tested, and potentially deployed independently, facilitating parallel team work, easier unit testing, and more focused integration testing.
-   **Maintainability and Scalability**: By isolating concerns, the system becomes easier to understand, modify, and extend. Specific layers can be scaled independently (e.g., adding more presentation servers) without impacting core business logic or data storage.
-   **Technology Agnosticism**: The core business logic (Domain Layer) remains independent of specific frameworks, databases, or UI technologies, increasing its longevity and reusability.

> [!important]
> Higher layers must only depend on lower layers, and each layer must maintain a distinct, cohesive responsibility, preventing direct access to non-adjacent layers or the mixing of concerns.

## Mental Model
A typical layered architecture processes requests by flowing them downwards through the layers and returning responses upwards.

-   **User Interaction/External Request** (e.g., HTTP Request, CLI Command, Message Queue Event)
    *   **Presentation Layer** (UI, API Endpoints, DTOs)
        *   Receives external requests and translates them into application-specific commands.
        *   Handles user authentication, authorization, and input validation specific to the external interface.
        *   Formats application responses for external consumption (e.g., rendering HTML, serializing JSON).
    *   **Application Layer** (Use Cases, Orchestration)
        *   Orchestrates application-specific workflows and coordinates tasks, delegating to the Domain Layer.
        *   Manages transaction boundaries, applies cross-cutting concerns (e.g., logging, caching), and enforces security checks.
        *   Does *not* contain core business rules itself, but rather coordinates their execution.
    *   **Domain Layer** (Entities, Value Objects, Aggregates, Domain Services, Repository Interfaces)
        *   Encapsulates the core business rules, logic, and invariants that define the business problem.
        *   Represents the state and behavior of the business, independent of any specific technology or framework.
        *   Defines interfaces (e.g., `IRepository`, `IMessageSender`) for external dependencies, but does not implement them.
    *   **Infrastructure Layer** (Persistence, Messaging, External Services, Concrete Repository Implementations)
        *   Provides generic technical capabilities to support higher layers.
        *   Handles details of databases, file systems, network communication, and external APIs.
        *   Implements interfaces defined in the Domain Layer (e.g., `UserRepository` interface implemented by `SqlUserRepository`).
-   **Response/External Output** (e.g., Rendered Web Page, JSON Response, Database Update, Message Published)

## Gotchas
-   **Leaky Abstractions**: Occurs when a lower layer's internal implementation details are exposed to or relied upon by a higher layer. This breaks encapsulation, increases coupling, and negates the benefits of layering, making changes difficult and unpredictable.
-   **Anemic Domain Model**: This anti-pattern places core business logic and behavior within the Application Layer or services, leaving Domain Layer entities as mere data holders (getters/setters). It leads to procedural programming, reduced reusability of domain logic, and difficulty enforcing business invariants.
-   **Circular Dependencies**: When Layer A depends on Layer B, and Layer B (or another layer it depends on) in turn depends on Layer A. This violates the hierarchical principle, makes the system extremely difficult to understand, test, and refactor, and can lead to compilation issues or runtime errors.
-   **Over-engineering**: Applying a highly layered or complex architectural pattern to a simple application that doesn't require it. This adds unnecessary overhead, increases development time, and introduces complexity without providing proportional benefits in maintainability or scalability.
-   **"God" Objects/Services**: A single class or service within a layer that accumulates an excessive number of responsibilities. This violates the Single Responsibility Principle, makes the component difficult to understand, test, and maintain, and creates a bottleneck for changes.
-   **Ignoring Layer Boundaries**: Directly accessing a non-adjacent layer (e.g., Presentation Layer directly calling the Infrastructure Layer). This bypasses the intended flow of control, security checks, and business logic orchestration, leading to inconsistent behavior and tight coupling.

> [!Tip]
> Consider a user placing an order in an e-commerce application. The **Presentation Layer** receives the HTTP request, validates input, and passes it to the **Application Layer**. The Application Layer orchestrates the `PlaceOrder` use case, invoking domain services within the **Domain Layer** to create an `Order` aggregate, apply business rules (e.g., check stock), and persist it. The Domain Layer uses a `ProductRepository` interface, which is concretely implemented by the **Infrastructure Layer** (e.g., `JpaProductRepository`) to interact with the database.