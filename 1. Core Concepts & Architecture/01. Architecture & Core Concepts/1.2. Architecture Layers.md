# Understanding Architecture Layers in Software Design

> [!Information]
> Architecture layers organize a system into distinct, hierarchical components, each with a specific responsibility, to manage complexity and improve maintainability.

## Why This Matters
-   **Decision Support**: Guides critical decisions on how to structure code, where to place business logic, how to organize development teams, and which technologies are appropriate for different system parts.
-   **Breaks or Costs Time**: Without clear layering, systems become monolithic and tightly coupled ("spaghetti code"), leading to difficult maintenance, slow feature development, increased bug introduction, and poor scalability. Misplaced logic can result in security vulnerabilities or performance bottlenecks.
-   **When You Would Look This Up**: Essential when initiating a new software project, planning a major refactoring, onboarding new engineers to a complex system, or diagnosing issues related to system complexity and coupling.

## Key Points
-   **Separation of Concerns**: Each layer is responsible for a distinct set of functionalities (e.g., presentation, business logic, data persistence), preventing intermingling of unrelated responsibilities.
-   **Hierarchical Structure**: Layers are typically arranged in a hierarchy, with higher layers depending on and utilizing services provided by lower layers.
-   **Controlled Dependencies**: Dependencies flow predominantly in one direction (e.g., presentation depends on application, application depends on domain, domain depends on infrastructure), preventing circular dependencies and simplifying understanding.
-   **Abstraction and Encapsulation**: Lower layers expose well-defined interfaces to higher layers, abstracting away internal implementation details and allowing changes within a layer without impacting others.
-   **Modularity and Testability**: Layers can be developed, tested, and even deployed with a degree of independence, facilitating parallel development and easier unit/integration testing of specific components.
-   **Maintainability and Scalability**: Isolating concerns makes it easier to understand, modify, and scale specific parts of the system without affecting the entire application.

> [!important]
> Higher layers must only depend on lower layers, and each layer must maintain a distinct, cohesive responsibility, preventing direct access to non-adjacent layers or the mixing of concerns.

## Mental Model
-   **User Interaction/External Request** (e.g., HTTP Request, CLI Command)
    *   **Presentation Layer** (UI, API Endpoints, DTOs)
        *   Translates external requests into application commands.
        *   Formats application responses for external consumption.
-   **Application Layer** (Use Cases, Orchestration)
    *   Coordinates and delegates tasks to the domain layer.
    *   Manages transaction boundaries and security checks.
    *   Does *not* contain core business rules itself.
-   **Domain Layer** (Entities, Value Objects, Aggregates, Domain Services, Repository Interfaces)
    *   Encapsulates the core business rules and logic.
    *   Represents the state and behavior of the business problem.
    *   Is independent of any specific technology or framework.
-   **Infrastructure Layer** (Persistence, Messaging, External Services, Concrete Repository Implementations)
    *   Provides generic technical capabilities to support higher layers.
    *   Handles details of databases, file systems, network communication, and external APIs.
    *   Implements interfaces defined in the Domain Layer (e.g., `UserRepository` interface implemented by `SqlUserRepository`).
-   **Response/External Output** (e.g., Rendered Web Page, JSON Response, Database Update)

## Gotchas
-   **Leaky Abstractions**: When a higher layer needs to understand or manipulate the internal details of a lower layer, breaking encapsulation and increasing coupling.
-   **Anemic Domain Model**: Business logic is incorrectly placed in the Application Layer, leaving Domain Layer entities as simple data structures without behavior, leading to procedural programming and reduced reusability.
-   **Circular Dependencies**: Two or more layers directly or indirectly depend on each other, making the system difficult to understand, test, and maintain, often indicating a violation of the hierarchical principle.
-   **Over-engineering**: Introducing too many layers or overly complex abstractions for a simple application, adding unnecessary overhead and complexity without proportional benefits.
-   **"God" Objects/Services**: A single component within a layer that accumulates too many responsibilities, becoming a bottleneck and violating the Single Responsibility Principle.

> [!Tip]
> Consider a user placing an order in an e-commerce application. The **Presentation Layer** receives the HTTP request, validates input, and passes it to the **Application Layer**. The Application Layer orchestrates the `PlaceOrder` use case, invoking domain services within the **Domain Layer** to create an `Order` aggregate, apply business rules (e.g., check stock), and persist it. The Domain Layer uses a `ProductRepository` interface, which is concretely implemented by the **Infrastructure Layer** (e.g., `JpaProductRepository`) to interact with the database.