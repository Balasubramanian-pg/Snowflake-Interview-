# What are Compute Models and How Do They Impact Cloud Computing?

> [!TIP]
> Compute models define how computing resources are allocated, managed, and scaled in cloud environments, directly impacting application performance, cost, and efficiency.

## Why This Matters
- Understanding compute models is crucial for designing and deploying scalable, secure, and cost-effective cloud applications.
- Getting it wrong can lead to overprovisioning, underutilization, or security breaches, resulting in significant financial losses and reputational damage.
- This knowledge is essential for cloud architects, developers, and IT professionals responsible for migrating, building, or managing applications in cloud environments.

## Key Points
- **Serverless Computing**: Executes code without provisioning or managing servers, ideal for event-driven applications.
- **Containerization**: Packages applications into containers, ensuring consistency and portability across environments.
- **Virtual Machines (VMs)**: Provides a virtualized environment for applications, offering flexibility and control over resources.

> [!important]
> Choosing the right compute model is non-negotiable, as it directly affects the application's scalability, security, and cost-efficiency.

## Visual Model (Mental)
- **Resource Allocation** → **Application Deployment** → **Scaling and Management**
- Or: **Workload Analysis** → **Compute Model Selection** → **Cloud Deployment**

## Gotchas
- **Overprovisioning**: Allocating more resources than needed, leading to unnecessary costs.
- **Underestimating Security**: Failing to consider security implications of the chosen compute model.
- **Ignoring Compliance**: Overlooking regulatory requirements and compliance issues related to data storage and processing.

> [!NOTE]
> For example, a company migrating a legacy application to the cloud might choose a VM-based compute model for consistency and control, while a startup building a new event-driven application might opt for serverless computing to minimize costs and maximize scalability.