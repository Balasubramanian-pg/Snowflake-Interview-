# 15.1. Use Cases

Canonical documentation for [15.1. Use Cases](2. Data Engineering & Pipelines/15. External Tables/15.1. Use Cases.md). This document defines concepts, terminology, and standard usage.

## Purpose
The primary purpose of Use Cases is to capture the functional requirements of a system by describing the interactions between external entities (Actors) and the system itself to achieve a specific, measurable goal. Use Cases serve as a bridge between stakeholder expectations and technical specifications, ensuring that the system design remains focused on delivering value to the end user.

By documenting behavior rather than internal implementation, Use Cases allow for a clear understanding of "what" the system does without prematurely constraining "how" it is built.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the methodology of use case modeling rather than specific software tools.

## Scope
This document covers the theoretical framework, structural components, and best practices for defining Use Cases within a system architecture or requirements engineering context.

> [!IMPORTANT]
> **In scope:**
> * Definition of Actors and System Boundaries.
> * Structural relationships (Include, Extend, Generalization).
> * Scenario modeling (Main Success Scenarios and Extensions).
> * Goal-oriented requirement gathering.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations or modeling software (e.g., UML tools).
> * User Story mapping in specific Agile frameworks (though related, User Stories are distinct from formal Use Cases).
> * Detailed UI/UX design specifications.

## Definitions
| Term | Definition |
|------|------------|
| Actor | An external entity (human, hardware, or another system) that interacts with the system to achieve a goal. |
| Primary Actor | The entity that initiates the interaction to achieve a specific goal. |
| Secondary Actor | An entity that the system needs assistance from to satisfy the Primary Actor’s goal (e.g., a payment gateway). |
| Scenario | A specific sequence of actions and interactions between actors and the system. |
| Main Success Scenario | The "happy path" where the goal is achieved without any errors or deviations. |
| Extension | A branch from the main scenario that handles exceptions, errors, or alternative logic. |
| System Boundary | The conceptual line separating the system under design from the external actors. |

## Core Concepts
Use Cases are built upon the principle of "Black Box" requirements. The system is treated as a black box that responds to stimuli from actors.

1.  **Goal-Oriented Design:** Every Use Case must yield a result of value to an actor. If a sequence of steps does not result in a tangible goal, it is likely a fragment of a Use Case rather than a complete one.
2.  **Narrative Flow:** Use Cases are typically written as a series of numbered steps, alternating between actor actions and system responses.
3.  **Level of Detail:** Use Cases can exist at different levels—from "Sea Level" (user goals) to "Fish Level" (sub-functions) or "Cloud Level" (high-level enterprise goals).

> [!TIP]
> Think of a Use Case like a script for a play. The Actors are the characters, the System is the stage/props, and the Use Case is the scene that must play out to reach a specific conclusion.

## Standard Model
The standard model for a Use Case consists of a structured template that ensures consistency across a project. A standard Use Case includes:

*   **Title:** A strong verb-noun phrase (e.g., "Withdraw Cash").
*   **Primary Actor:** The stakeholder driving the action.
*   **Preconditions:** What must be true before the Use Case can begin.
*   **Postconditions:** The state of the system after the Use Case is successfully completed.
*   **Main Success Scenario:** The step-by-step interaction.
*   **Extensions/Alternative Flows:** Logic for handling deviations (e.g., "Insufficient Funds").

## Common Patterns
*   **<<include>>:** Used when a chunk of behavior is common to multiple Use Cases (e.g., "Verify Identity" included in both "Withdraw Cash" and "Transfer Funds").
*   **<<extend>>:** Used to describe optional behavior or behavior that only runs under specific conditions (e.g., "Calculate Currency Conversion" extending "Transfer Funds").
*   **Actor Generalization:** When multiple actors share the same role (e.g., a "Manager" actor inheriting all permissions from an "Employee" actor).

## Anti-Patterns
*   **Functional Decomposition:** Breaking Use Cases down into such small pieces that they no longer represent a complete user goal.
*   **The CRUD Trap:** Creating a separate Use Case for every Create, Read, Update, and Delete action, leading to "documentation bloat" instead of meaningful behavior.
*   **UI Dependency:** Describing specific buttons, screens, or clicks (e.g., "User clicks the blue submit button"). This makes the documentation brittle and overly coupled to design.

> [!CAUTION]
> Avoid circular dependencies where Use Case A includes Use Case B, and Use Case B includes Use Case A. This creates logical paradoxes in system requirements.

## Edge Cases
*   **System-Only Use Cases:** Scenarios where the "Primary Actor" is a timer or an internal trigger (e.g., "Generate Monthly Report"). While technically valid, these are often better handled as system services.
*   **Abstract Use Cases:** Use Cases that are never instantiated on their own but provide a template for specialized child Use Cases.
*   **The "Never-Ending" Scenario:** Use Cases that lack a clear postcondition or exit criteria, leading to ambiguity in testing.

## Related Topics
*   **15.2. Requirements Traceability:** How Use Cases map to business rules and technical tests.
*   **System Sequence Diagrams (SSD):** Visual representations of the interactions defined in a Use Case.
*   **Domain Modeling:** Defining the entities that the Use Cases manipulate.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-17 | Initial AI-generated canonical documentation |