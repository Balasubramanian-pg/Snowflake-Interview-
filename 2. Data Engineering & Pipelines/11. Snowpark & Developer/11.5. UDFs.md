# 11.5. UDFs

Canonical documentation for [11.5. UDFs](2. Data Engineering & Pipelines/11. Snowpark & Developer/11.5. UDFs.md). This document defines concepts, terminology, and standard usage.

## Purpose
User-Defined Functions (UDFs) exist to provide a mechanism for extending the native functionality of a host systemâ€”typically a database, data processing engine, or spreadsheet application. While host systems provide a robust set of primitive operations, they cannot anticipate every domain-specific requirement or complex business logic. 

UDFs address the need for modularity, code reuse, and encapsulation by allowing users to define custom logic that can be invoked within the system's standard execution flow as if it were a built-in feature.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural role of UDFs rather than specific programming languages.

## Scope
The scope of this documentation covers the theoretical framework, lifecycle, and operational characteristics of custom functional extensions within a host environment.

> [!IMPORTANT]
> **In scope:**
> * Functional classification (Scalar, Aggregate, Table-valued)
> * Determinism and side-effect theory
> * Execution contexts and security sandboxing
> * Interface definitions between host and user code

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., T-SQL, PL/pgSQL, JavaScript in BigQuery)
> * Syntax-specific debugging guides
> * Installation instructions for specific runtime environments

## Definitions
| Term | Definition |
|------|------------|
| Scalar UDF | A function that accepts zero or more input values and returns a single, atomic value. |
| Aggregate UDF | A function that operates on a collection of values and returns a single summarized value. |
| Table-Valued Function (TVF) | A function that returns a structured set of rows (a virtual table) rather than a scalar value. |
| Determinism | A property where a function consistently returns the same output for the same set of input values and state. |
| Side Effect | An observable change in the system state (e.g., modifying a global variable or writing to a file) outside of the function's return value. |
| Sandboxing | The practice of isolating UDF execution to prevent custom code from compromising the host system's stability or security. |

## Core Concepts

### Functional Mapping
UDFs are defined by their mapping cardinality. A Scalar UDF represents a 1:1 mapping (one result per input set), while an Aggregate UDF represents an N:1 mapping. Table-Valued Functions represent 1:N or N:M mappings, allowing for the generation of complex datasets from simple parameters.

### Execution Context
UDFs operate within a specific context provided by the host. This context determines what data the UDF can access, the permissions it inherits, and the resource limits (CPU, memory) imposed upon it.

> [!TIP]
> Think of a UDF as a "guest" in the host system's "house." The host provides the utilities (data, memory), but the guest must follow the house rules (security, resource limits) to ensure the house remains standing.

### Determinism and Optimization
Host systems use determinism to optimize execution. If a function is marked as deterministic, the system may cache results or reorder execution. If a function is non-deterministic (e.g., returning the current system time), the host must execute it for every invocation to ensure correctness.

## Standard Model
The standard model for UDF implementation follows a four-stage lifecycle:

1.  **Definition/Registration:** The user provides the logic and metadata (input types, return types, determinism) to the host system.
2.  **Validation:** The host system checks the UDF for type safety, syntax errors, and permission compliance.
3.  **Invocation:** The UDF is called within a larger operation (e.g., a query or a calculation chain). The host passes arguments to the UDF runtime.
4.  **Execution & Return:** The UDF logic processes the inputs and returns the result to the host's execution engine, which integrates the result back into the primary workflow.

## Common Patterns

### Data Transformation and Normalization
UDFs are frequently used to standardize data formats (e.g., converting proprietary date strings into ISO-8601) that are not natively supported by the host system.

### Business Logic Encapsulation
Complex calculations, such as tax logic or risk scoring, are encapsulated within UDFs to ensure consistency across multiple reports or applications. This prevents "logic drift" where different parts of a system calculate the same metric differently.

### Polyglot Integration
UDFs allow users to leverage specialized libraries from other languages (e.g., using a Python machine learning library within a SQL environment) to perform tasks the host language is ill-equipped to handle.

## Anti-Patterns

### Row-by-Row Processing (RBAR)
In set-based systems (like SQL engines), using a Scalar UDF that performs complex logic or additional lookups can force the engine to switch contexts for every single row, leading to massive performance degradation.

### Hidden Side Effects
Defining a UDF that appears to be a simple calculation but secretly modifies external state or logs to a database can lead to unpredictable behavior, especially during system rollbacks or parallel execution.

> [!CAUTION]
> Avoid circular dependencies where UDF A calls UDF B, which in turn calls UDF A. Most host systems cannot detect these at registration time, leading to stack overflows or infinite loops during runtime.

## Edge Cases

### Null and Empty Input Handling
UDFs often fail when encountering `NULL` or empty inputs if the logic does not explicitly account for them. Canonical UDF design should define whether the function returns `NULL` on `NULL` input (strictness) or handles it via custom logic.

### Resource Exhaustion
A UDF that performs recursive calculations or allocates large amounts of memory can crash the host process if the sandbox does not strictly enforce memory limits.

### Versioning and Dependency Drift
If a UDF relies on an external library, updates to that library can change the UDF's output, potentially breaking downstream systems that rely on the function's previous behavior.

## Related Topics
*   **Stored Procedures:** Unlike UDFs, these are typically used for procedural flow control and side effects rather than returning values within an expression.
*   **Built-in Functions:** The native primitives provided by the host system.
*   **Functional Programming:** The mathematical basis for UDF design and determinism.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-17 | Initial AI-generated canonical documentation |