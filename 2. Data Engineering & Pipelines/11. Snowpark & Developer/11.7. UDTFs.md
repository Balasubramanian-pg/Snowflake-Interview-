# 11.7. UDTFs

Canonical documentation for [11.7. UDTFs](2. Data Engineering & Pipelines/11. Snowpark & Developer/11.7. UDTFs.md). This document defines concepts, terminology, and standard usage.

## Purpose
User-Defined Table Functions (UDTFs) serve as a mechanism to extend the capabilities of a data processing system by allowing users to define custom logic that outputs a relational result set (a table) rather than a single scalar value. 

The primary purpose of a UDTF is to facilitate complex data transformations that require "one-to-many" or "many-to-many" mapping. While standard scalar functions return a single value for every input row, UDTFs can produce zero, one, or multiple rows for each input, effectively acting as a programmable data source or a sophisticated transformation operator within a query pipeline.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the relational theory and functional requirements of UDTFs.

## Scope
This section clarifies the boundaries of the UDTF definition and its application within data systems.

> [!IMPORTANT]
> **In scope:**
> * Functional definitions of tabular output.
> * Input parameter types (scalar and relational).
> * Execution lifecycle (initialization, processing, and termination).
> * Schema determination (static vs. dynamic).

> [!WARNING]
> **Out of scope:**
> * Specific programming language syntax (e.g., Python, Java, JavaScript, SQL).
> * Vendor-specific optimization hints or proprietary keywords.
> * Performance benchmarking for specific hardware architectures.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| UDTF | A function that returns a collection of rows (a table) as its output. |
| Scalar Input | Individual data values passed as arguments to the function. |
| Table Input | A set of rows (a relation) passed as an argument to the function, often referred to as "Table-In, Table-Out." |
| Cardinality | The number of rows returned by the function relative to the number of input rows. |
| Schema Discovery | The process by which the system determines the names and types of the columns returned by the UDTF. |
| Lateral Join | A join operation that allows a UDTF to be called for each row of a preceding table in the query. |

## Core Concepts
The fundamental idea behind a UDTF is the transformation of input data into a structured tabular format. Unlike a view, which is a saved query, a UDTF is procedural or functional logic that generates data dynamically.

### Row Generation and Expansion
UDTFs are the primary tool for "exploding" data. For example, a single row containing a delimited string or a complex JSON array can be passed into a UDTF, which then parses the content and emits each element as a separate row in the output table.

### The Execution Lifecycle
A standard UDTF typically follows a three-stage lifecycle:
1.  **Setup/Initialization:** The function prepares internal state or resources.
2.  **Process:** The function receives input data and "yields" or "emits" rows to the output stream.
3.  **Teardown/Finalization:** The function performs cleanup or emits final summary rows after all inputs are processed.

> [!TIP]
> Think of a UDTF as a "pipe" that can take a single drop of water and turn it into a spray, or take a stream and filter/reshape it into a new stream.

## Standard Model
The standard model for UDTFs involves defining the function signature, the output schema, and the processing logic.

1.  **Input Handling:** UDTFs may accept scalar arguments (e.g., a constant or a column value) or, in advanced models, entire tables as input.
2.  **Output Schema:** The output schema must be defined so the query engine knows how to handle the resulting columns. This can be **Static** (fixed at creation time) or **Dynamic** (determined at runtime based on inputs).
3.  **Integration:** In a relational context, UDTFs are typically invoked in the `FROM` clause of a query. When used in conjunction with other tables, they often utilize a "lateral" reference, allowing the function to be evaluated once for every row produced by the preceding table expression.

## Common Patterns
*   **Data Parsing:** Converting unstructured or semi-structured blobs (XML, JSON, Log files) into structured relational rows.
*   **Time-Series Generation:** Producing a range of dates or timestamps between a start and end point.
*   **External Integration:** Fetching data from an external API or filesystem and presenting it as a table within the database engine.
*   **Pivot/Unpivot Operations:** Custom logic to rotate data axes when standard relational operators are insufficient.

## Anti-Patterns
*   **Scalar Logic Overload:** Using a UDTF to return a single column and single row when a standard scalar UDF would suffice. This introduces unnecessary overhead.
*   **Side Effects:** Modifying global state or external data within a UDTF. UDTFs should ideally be idempotent and functional to allow for query parallelization.
*   **Opaque Logic:** Implementing complex business logic inside a UDTF that could be more efficiently handled by native relational joins and filters, which the query optimizer understands better.

> [!CAUTION]
> Avoid creating UDTFs that rely on a specific execution order of input rows unless the system explicitly guarantees ordered processing, as this leads to non-deterministic results in parallel environments.

## Edge Cases
*   **Zero-Row Output:** A UDTF may receive valid input but return no rows. The calling query must be designed to handle the potential disappearance of the "source" row if using an inner-join semantic.
*   **Null Inputs:** Handling `NULL` scalar arguments or empty input tables requires explicit logic to prevent the function from crashing or returning unexpected results.
*   **Polymorphic Output:** Some systems allow UDTFs to return different sets of columns depending on the input. This requires the query engine to support "Schema-on-Read" or dynamic type resolution.
*   **Resource Exhaustion:** Because a UDTF can emit an infinite number of rows (e.g., a recursive generator), it must be bounded or monitored to prevent memory or storage exhaustion.

## Related Topics
*   **Scalar UDFs:** Functions returning a single value.
*   **Window Functions:** Functions that perform calculations across a set of table rows related to the current row.
*   **Lateral Joins / Cross Apply:** The relational operators used to invoke UDTFs per row.
*   **Table Expressions:** The broader category of objects that can appear in a `FROM` clause.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-02-17 | Initial AI-generated canonical documentation |